[[id=java.util.concurrent.CountDownLatch]]
= CountDownLatch

"Count Down" åœ¨è‹±è¯­ä¸­æ„ä¸ºå€’è®¡æ•°ï¼Œä¸€ä¸ªå…¸å‹åœºæ™¯å°±æ˜¯ç«ç®­ğŸš€å‘å°„æ—¶çš„å€’è®¡æ—¶ã€‚å®ƒå…è®¸ä¸€ä¸ªæˆ–å¤šä¸ªçº¿ç¨‹ç­‰å¾…å…¶ä»–çº¿ç¨‹å®Œæˆæ“ä½œã€‚


[{java_src_attr}]
----
include::{sourcedir}/concurrent/CountDownLatchTest.java[]
----

ä¸‹é¢ï¼Œæˆ‘ä»¬å¼€å§‹çœ‹ `CountDownLatch` æºç ï¼š

`CountDownLatch` ç±»ä¸­å­˜åœ¨ä¸€ä¸ªå†…éƒ¨ç±» `Sync`ï¼Œç»§æ‰¿è‡ª `AbstractQueuedSynchronizer`ï¼Œä»£ç å¦‚ä¸‹ï¼š

[{java_src_attr}]
----
/**
 * Synchronization control For CountDownLatch.
 * Uses AQS state to represent count.
 */
private static final class Sync extends AbstractQueuedSynchronizer {
    private static final long serialVersionUID = 4982264981922014374L;

    Sync(int count) {
        setState(count);
    }

    int getCount() {
        return getState();
    }

    protected int tryAcquireShared(int acquires) {
        return (getState() == 0) ? 1 : -1;
    }

    protected boolean tryReleaseShared(int releases) {
        // Decrement count; signal when transition to zero
        for (;;) {
            int c = getState();
            if (c == 0)
                return false;
            int nextc = c - 1;
            if (compareAndSetState(c, nextc))
                return nextc == 0;
        }
    }
}

private final Sync sync;
----

ç®¡ä¸­çª¥è±¹ï¼Œä»è¿™é‡Œä¹Ÿå¯ä»¥çœ‹å‡º `CountDownLatch` ä¸­çš„ç­‰å¾…æ§åˆ¶å‡ ä¹éƒ½æ˜¯ä¾èµ– `AbstractQueuedSynchronizer` æ¥å®ç°çš„ã€‚

== `await()`

[{java_src_attr}]
----
/**
 * Causes the current thread to wait until the latch has counted down to
 * zero, unless the thread is {@linkplain Thread#interrupt interrupted}.
 *
 * <p>If the current count is zero then this method returns immediately.
 *
 * <p>If the current count is greater than zero then the current
 * thread becomes disabled for thread scheduling purposes and lies
 * dormant until one of two things happen:
 * <ul>
 * <li>The count reaches zero due to invocations of the
 * {@link #countDown} method; or
 * <li>Some other thread {@linkplain Thread#interrupt interrupts}
 * the current thread.
 * </ul>
 *
 * <p>If the current thread:
 * <ul>
 * <li>has its interrupted status set on entry to this method; or
 * <li>is {@linkplain Thread#interrupt interrupted} while waiting,
 * </ul>
 * then {@link InterruptedException} is thrown and the current thread's
 * interrupted status is cleared.
 *
 * @throws InterruptedException if the current thread is interrupted
 *         while waiting
 */
public void await() throws InterruptedException {
    sync.acquireSharedInterruptibly(1);
}
----

å¯¹ `await()` çš„å¤„ç†ç›´æ¥å§”æ‰˜ç»™äº† `sync` çš„ `acquireSharedInterruptibly(1)` æ–¹æ³•ï¼Œå½“ç„¶è¿™ä¸ªæ–¹æ³•æ˜¯ä» `AbstractQueuedSynchronizer` ç»§æ‰¿è€Œæ¥çš„ã€‚æ¥çœ‹ä¸€ä¸‹è¿™ä¸ªæ–¹æ³•ï¼š

.AbstractQueuedSynchronizer
[{java_src_attr}]
----
    /**
     * Acquires in shared mode, aborting if interrupted.  Implemented
     * by first checking interrupt status, then invoking at least once
     * {@link #tryAcquireShared}, returning on success.  Otherwise the
     * thread is queued, possibly repeatedly blocking and unblocking,
     * invoking {@link #tryAcquireShared} until success or the thread
     * is interrupted.
     * @param arg the acquire argument.
     * This value is conveyed to {@link #tryAcquireShared} but is
     * otherwise uninterpreted and can represent anything
     * you like.
     * @throws InterruptedException if the current thread is interrupted
     */
    public final void acquireSharedInterruptibly(int arg)
            throws InterruptedException {
        if (Thread.interrupted())
            throw new InterruptedException();
        if (tryAcquireShared(arg) < 0)
            doAcquireSharedInterruptibly(arg);
    }
----

ç»“åˆä¸Šé¢æåˆ°çš„ `Sync` ä¸­çš„ `tryAcquireShared(int acquires)` æ–¹æ³•ï¼Œå¯ä»¥çœ‹å‡ºï¼Œå½“ `getState()` ä¸ä¸ºé›¶æ—¶ï¼Œå°±ä¼šå¯¼è‡´ `tryAcquireShared(arg)` ç»“æœè¿”å›å°äºé›¶ï¼Œè¿›è€Œè°ƒç”¨ `doAcquireSharedInterruptibly(arg)`ï¼Œå°†çº¿ç¨‹è¿›å…¥æ’é˜Ÿï¼Œç„¶åæŒ‚èµ·çº¿ç¨‹ã€‚


image::assets/images/CountDownLatch-await-park.png[]

image::assets/images/CountDownLatch-await-unpark.png[]

== `countDown()`

[{java_src_attr}]
----
/**
 * Decrements the count of the latch, releasing all waiting threads if
 * the count reaches zero.
 *
 * <p>If the current count is greater than zero then it is decremented.
 * If the new count is zero then all waiting threads are re-enabled for
 * thread scheduling purposes.
 *
 * <p>If the current count equals zero then nothing happens.
 */
public void countDown() {
    sync.releaseShared(1);
}
----

è¿™é‡Œçš„ `releaseShared(1)` æ–¹æ³•æ˜¯ä» `AbstractQueuedSynchronizer` ç»§æ‰¿è¿‡æ¥çš„ï¼Œæ¥çœ‹ä¸€ä¸‹è¿™ä¸ªæ–¹æ³•çš„å®ç°ï¼š

.AbstractQueuedSynchronizer
[{java_src_attr}]
----
    /**
     * Releases in shared mode.  Implemented by unblocking one or more
     * threads if {@link #tryReleaseShared} returns true.
     *
     * @param arg the release argument.  This value is conveyed to
     *        {@link #tryReleaseShared} but is otherwise uninterpreted
     *        and can represent anything you like.
     * @return the value returned from {@link #tryReleaseShared}
     */
    public final boolean releaseShared(int arg) {
        if (tryReleaseShared(arg)) {
            doReleaseShared();
            return true;
        }
        return false;
    }
----

ç»“åˆä¸Šé¢æåˆ°çš„ `Sync` ä¸­çš„ `tryReleaseShared(int releases)` æ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹å‡ºï¼š`countDown()` æ–¹æ³•ç›´æ¥å‡å°‘é”å­˜å™¨è®¡æ•°ï¼Œå¦‚æœä¸ä¸ºé›¶ï¼Œåˆ™æ— æ‰€ä½œä¸ºï¼›å‡å°‘åˆ°é›¶ï¼Œåˆ™é‡Šæ”¾æ‰€æœ‰ä¸Šè¿°é€šè¿‡ `await()` æ–¹æ³•æŒ‚èµ·çš„æ‰€æœ‰ç­‰å¾…çº¿ç¨‹ã€‚

image::assets/images/CountDownLatch-countDown-1.png[]

image::assets/images/CountDownLatch-countDown-2.png[]

[qanda]
`CountDownLatch` ä¸ºä»€ä¹ˆä½¿ç”¨å…±äº«é”ï¼Ÿ::
ç­”ï¼šå‰é¢æˆ‘ä»¬åˆ†æ `ReentrantReadWriteLock` çš„æ—¶å€™å­¦ä¹ è¿‡AQSçš„å…±äº«é”æ¨¡å¼ï¼Œæ¯”å¦‚å½“å‰é”æ˜¯ç”±ä¸€ä¸ªçº¿ç¨‹è·å–ä¸ºäº’æ–¥é”ï¼Œé‚£ä¹ˆè¿™æ—¶å€™æ‰€æœ‰éœ€è¦è·å–å…±äº«é”çš„çº¿ç¨‹éƒ½è¦è¿›å…¥AQSé˜Ÿåˆ—ä¸­è¿›è¡Œæ’é˜Ÿï¼Œå½“è¿™ä¸ªäº’æ–¥é”é‡Šæ”¾çš„æ—¶å€™ï¼Œä¼šä¸€ä¸ªæ¥ç€ä¸€ä¸ªåœ°å”¤é†’è¿™äº›è¿ç»­çš„æ’é˜Ÿçš„ç­‰å¾…è·å–å…±äº«é”çš„çº¿ç¨‹ï¼Œæ³¨æ„ï¼Œè¿™é‡Œçš„ç”¨è¯­æ˜¯â€œä¸€ä¸ªæ¥ç€ä¸€ä¸ªåœ°å”¤é†’â€ï¼Œä¹Ÿå°±æ˜¯è¯´è¿™äº›ç­‰å¾…è·å–å…±äº«é”çš„çº¿ç¨‹ä¸æ˜¯ä¸€æ¬¡æ€§å”¤é†’çš„ã€‚

== å‚è€ƒèµ„æ–™

. https://www.cnblogs.com/leesf456/p/5406191.html[ã€JUCã€‘JDK1.8æºç åˆ†æä¹‹CountDownLatchï¼ˆäº”ï¼‰ - leesf - åšå®¢å›­]
. https://juejin.im/post/5d0660f2518825092c7170dd[æ­»ç£• javaåŒæ­¥ç³»åˆ—ä¹‹CountDownLatchæºç è§£æ - æ˜é‡‘]

